# Intuition

* The malware spreads within **connected components** of the graph.
* If a connected component has **only one initially infected node**, then removing that node will save the entire component from being infected.
* If a component has **more than one infected node**, then removing just one won’t help, since the others will still spread malware there.

So the strategy:

1. Identify connected components in the graph.
2. For each component, count its size and how many initially infected nodes are in it.
3. For each candidate node to remove, compute how many nodes would be saved.
4. Choose the node that maximizes saved nodes.

   * If multiple nodes save the same, choose the smallest index.

---

# Approach

1. Use **DFS or Union-Find** to find connected components.

   * Assign each node a `componentId`.
   * Record component sizes.
2. Count how many initially infected nodes fall into each component.
3. For each infected node:

   * If it’s the only infected in its component, removing it saves all other nodes in that component.
   * Otherwise, it saves 0.
4. Pick the node that saves the most. If tie, pick the smallest index.

---

# Complexity

* Building connected components: **O(N²)** (since adjacency matrix).
* Processing infections: **O(N)**.
* Overall: **O(N²)**, which is fine for `N ≤ 100`.

---

# Code

```java
import java.util.*;

public class Solution {
    public static int minMalwareSpread(ArrayList<ArrayList<Integer>> graph, ArrayList<Integer> initial) {
        int n = graph.size();
        Collections.sort(initial);
        
        int bestNode = initial.get(0);
        int minInfected = Integer.MAX_VALUE;
        
        for (int remove : initial) {
            boolean[] infected = new boolean[n];
            Queue<Integer> q = new LinkedList<>();
            
            // start infection from all initial nodes except the removed one
            for (int node : initial) {
                if (node != remove) {
                    infected[node] = true;
                    q.add(node);
                }
            }
            
            // BFS infection spread
            while (!q.isEmpty()) {
                int u = q.poll();
                for (int v = 0; v < n; v++) {
                    if (graph.get(u).get(v) == 1 && !infected[v] && v != remove) {
                        infected[v] = true;
                        q.add(v);
                    }
                }
            }
            
            // count infected
            int count = 0;
            for (int i = 0; i < n; i++) {
                if (infected[i]) count++;
            }
            
            if (count < minInfected || (count == minInfected && remove < bestNode)) {
                minInfected = count;
                bestNode = remove;
            }
        }
        
        return bestNode;
    }
}

```

---

## Walkthrough

### Example 1

```
Graph:
1 0 1
0 1 1
1 1 1
Initial: [0, 2]
```

* Components:

  * All nodes {0,1,2} form one component of size 3.
* Infected count:

  * Component has 2 infections (0 and 2).
* Evaluate:

  * Remove 0 → component still has 2 → saves 0.
  * Remove 2 → component still has 2 → saves 0.
* But since removing 2 means only node 0 spreads (node 1 also infected), the minimized infected count = 1.
* Answer: **2**.

---
