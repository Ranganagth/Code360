# Intuition

A perfect square is a number that can be written as `x * x`, where `x` is an integer. Since `N` can be as large as `10^18`, we need an efficient way to check whether a number is a perfect square **without overflow** or using built-in square root functions.

---

# Approach

Use **binary search** to find an integer `mid` such that `mid * mid == N`.
If such a number exists, `N` is a perfect square.
Otherwise, it’s not.

Steps:
1. Start binary search with `start = 1` and `end = N / 2` (or `end = N` for smaller values).
2. For each `mid`, calculate `mid * mid` using `mid <= N / mid` to avoid overflow.
3. If `mid * mid == N`, return true.
4. Otherwise, move the search range accordingly.
5. If no such number is found, return false.

---

# Complexity

* **Time complexity:**
  $O(\log N)$ — Binary search over the range `[1, N/2]`

* **Space complexity:**
  $O(1)$ — No extra space used

---

# Code

```java
import java.util.*;

public class Solution {
    public static boolean isPerfectSquare(long n) {
        if (n < 1) return false;
        long low = 1;
        long high = n;

        while (low <= high) {
            long mid = low + (high - low) / 2;
            long div = n / mid;

            if (mid == div && mid * mid == n) {
                return true;
            } else if (mid > div) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }

        return false;
    }

    // Driver code for testing
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = Integer.parseInt(sc.nextLine());

        while (T-- > 0) {
            long n = Long.parseLong(sc.nextLine());
            System.out.println(isPerfectSquare(n) ? "Yes" : "No");
        }

        sc.close();
    }
}
```

---
### **Examples**

**Input**

```
2
4
7
```

**Output**

```
Yes
No
```

---
