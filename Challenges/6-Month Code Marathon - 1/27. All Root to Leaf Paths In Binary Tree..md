# Intuition

We are asked to find **all root-to-leaf paths** in a binary tree.

* A **leaf node** is a node with no left or right child.
* Each path from the root to a leaf can be represented as a string of node values separated by spaces.

To generate all paths:

* We can use **Depth-First Search (DFS)**.
* Keep track of the current path while traversing.
* When we reach a leaf, convert the path to a string and store it.

---

# Approach

1. Create a helper function `dfs(node, path, result)`:

   * If `node` is `null`, return.
   * Add `node.data` to the current `path`.
   * If `node` is a leaf:

     * Convert `path` to a string separated by spaces.
     * Add it to `result`.
   * Recursively call `dfs` on `node.left` and `node.right`.
   * Backtrack: remove the last node from `path` (for DFS to explore other paths).
2. Call `dfs(root, [], result)`.
3. Return the list `result`.

---

# Complexity

* **Time Complexity:** `O(n)`
  Each node is visited exactly once, and building strings for each leaf takes O(path length), which is bounded by `O(n)` in worst case.
* **Space Complexity:** `O(h + l)`

  * `h` → recursion stack depth (height of tree)
  * `l` → storage for paths in result list

---

# Code

```java
import java.util.*;

public class Solution {

    public static List<String> allRootToLeaf(BinaryTreeNode root) {
        List<String> result = new ArrayList<>();
        if (root == null) return result;
        dfs(root, new ArrayList<>(), result);
        return result;
    }

    private static void dfs(BinaryTreeNode node, List<Integer> path, List<String> result) {
        if (node == null) return;

        // Add current node to path
        path.add(node.data);

        // If leaf, convert path to string and add to result
        if (node.left == null && node.right == null) {
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < path.size(); i++) {
                sb.append(path.get(i));
                if (i != path.size() - 1) sb.append(" ");
            }
            result.add(sb.toString());
        } else {
            // Recurse on left and right
            dfs(node.left, path, result);
            dfs(node.right, path, result);
        }

        // Backtrack: remove current node
        path.remove(path.size() - 1);
    }
}
```

---

## Example Walkthrough

### Input Tree:

```
        1
       / \
      2   3
     / \
    4   5
```

* Call `dfs(root, [], result)`
* Path updates as:

  1. `[1]`
  2. `[1,2]`
  3. `[1,2,4]` → leaf → add `"1 2 4"`
  4. Backtrack to `[1,2]`
  5. `[1,2,5]` → leaf → add `"1 2 5"`
  6. Backtrack to `[1]`
  7. `[1,3]` → leaf → add `"1 3"`

### Output:

```
1 2 4
1 2 5
1 3
```

---
