# Intuition

We are given a dictionary of words already sorted lexicographically according to the rules of some alien language.
The relative ordering of characters can be deduced by comparing **two consecutive words** in the dictionary:

* For the first differing character between the two words, we know the alien language dictates that `char1` comes before `char2`.
  This gives us a **directed edge** in a graph (`char1 → char2`).

Once we gather all such edges, the problem reduces to finding a **valid topological ordering of characters** in the graph.

---

# Approach

1. **Graph Construction**

   * Create a graph with `k` vertices (for each possible alien character).
   * Compare each adjacent pair of words (`dictionary[i]` and `dictionary[i+1]`).
   * For the first position where the characters differ, add a directed edge `u → v` (meaning `u` comes before `v`).

2. **Topological Sort**

   * Use **Kahn’s Algorithm (BFS with indegree)** to perform topological sort.
   * Initialize indegree of all nodes.
   * Push all characters with `indegree == 0` into a queue.
   * Repeatedly pop from queue, append to result, and decrease indegree of its neighbors.

3. **Result**

   * The order of popping gives the alien alphabet order.
   * Convert the topological order list into a string.

---

# Complexity

* Let `N` = number of words, `L` = max length of a word, `K` = alphabet size.
* **Building graph:** O(N \* L) (comparing adjacent words).
* **Topological sort:** O(K + E), where E ≤ K² in worst case.
* **Overall:** O(N \* L + K + E) ≈ O(N \* L).
* **Space:** O(K + E) for graph + result.

---

# Code

```java
import java.util.*;

public class Solution {
    public static String getAlienLanguage(String[] dictionary, int k) {
        // Step 1: Build graph
        List<List<Integer>> adj = new ArrayList<>();
        for (int i = 0; i < k; i++) {
            adj.add(new ArrayList<>());
        }

        // Compare adjacent words to find ordering rules
        for (int i = 0; i < dictionary.length - 1; i++) {
            String w1 = dictionary[i];
            String w2 = dictionary[i + 1];
            int len = Math.min(w1.length(), w2.length());

            for (int j = 0; j < len; j++) {
                if (w1.charAt(j) != w2.charAt(j)) {
                    adj.get(w1.charAt(j) - 'a').add(w2.charAt(j) - 'a');
                    break; // Only first different character matters
                }
            }
        }

        // Step 2: Topological Sort using Kahn's Algorithm
        int[] indegree = new int[k];
        for (int u = 0; u < k; u++) {
            for (int v : adj.get(u)) {
                indegree[v]++;
            }
        }

        Queue<Integer> q = new LinkedList<>();
        for (int i = 0; i < k; i++) {
            if (indegree[i] == 0) {
                q.add(i);
            }
        }

        StringBuilder order = new StringBuilder();
        while (!q.isEmpty()) {
            int node = q.poll();
            order.append((char) (node + 'a'));
            for (int nei : adj.get(node)) {
                indegree[nei]--;
                if (indegree[nei] == 0) {
                    q.add(nei);
                }
            }
        }

        return order.toString();
    }
}
```

---

## Example Walkthrough

Input:

```
dictionary = ["caa", "aaa", "aab"], k = 3
```

1. Compare `"caa"` and `"aaa"` → first differing char: `c` vs `a`. Rule: `c → a`.
2. Compare `"aaa"` and `"aab"` → first differing char: `a` vs `b`. Rule: `a → b`.

Graph:

```
c → a → b
```

Topological Sort:

* indegree: c=0, a=1, b=1.
* Start with `c`. Result = "c".
* Remove edge `c→a`. indegree\[a]=0 → push `a`.
* Result = "ca".
* Remove edge `a→b`. indegree\[b]=0 → push `b`.
* Result = "cab".

Output:

```
"cab"
```

---
