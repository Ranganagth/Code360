# Intuition

* Each cell `(i, j)` in the grid unlocks at a given time: `grid[i][j]`.
* You can only **move to 4-directionally adjacent cells** and **only if both current and adjacent cells are unlocked**.
* You can **move infinitely fast** once cells are unlocked.
* So the goal is to **reach the bottom-right cell (N-1, N-1)** as early as possible while satisfying unlock conditions.

---

# Approach

1. Start at `(0, 0)` with time `grid[0][0]`.
2. Use a **min-heap (priority queue)** to always explore the cell which can be reached at the earliest time.
3. At each step:
   * From `(i, j)`, try to move to neighbors `(ni, nj)`.
   * You can only go to `(ni, nj)` if it’s within bounds.
   * To move there, the time must be at least `max(currentTime, grid[ni][nj])`.
4. Track the minimum time to reach each cell using a `visited` matrix.
5. Stop when you reach `(N-1, N-1)`.

---

# Complexity Analysis

* **Time**: O(N² log N) — All N² cells, each added to the heap once.
* **Space**: O(N²) — For visited tracking and the heap.

---

# Code

```java
import java.util.*;

public class Solution {
    static class Cell implements Comparable<Cell> {
        int time, row, col;
        Cell(int t, int r, int c) {
            time = t; row = r; col = c;
        }
        public int compareTo(Cell other) {
            return Integer.compare(this.time, other.time);
        }
    }

    public static int lastCellLeastTime(int[][] grid, int n) {
        boolean[][] visited = new boolean[n][n];
        PriorityQueue<Cell> pq = new PriorityQueue<>();
        pq.add(new Cell(grid[0][0], 0, 0)); // Start at (0,0) at its unlock time

        int[] dx = {0, 0, -1, 1};
        int[] dy = {1, -1, 0, 0};

        while (!pq.isEmpty()) {
            Cell curr = pq.poll();
            int time = curr.time, i = curr.row, j = curr.col;

            if (visited[i][j]) continue;
            visited[i][j] = true;

            if (i == n - 1 && j == n - 1) return time;

            for (int d = 0; d < 4; d++) {
                int ni = i + dx[d];
                int nj = j + dy[d];

                if (ni >= 0 && nj >= 0 && ni < n && nj < n && !visited[ni][nj]) {
                    int unlockTime = Math.max(time, grid[ni][nj]);
                    pq.add(new Cell(unlockTime, ni, nj));
                }
            }
        }
        return -1; // Fallback, unreachable case
    }
}
```

---

### **Example Walkthrough**

Input:

```
2
2
0 1
2 3
```

Unlock times:

```
0 1
2 3
```

* Start at (0,0) at time 0.
* Can go to (0,1) at time 1, then (1,1) at time 3.
* Minimum time to reach (1,1): **3**.

**Output:**

```
3
```

---
