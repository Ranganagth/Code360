# Intuition

* **Preorder** gives us the **root first**, then left subtree, then right subtree.
* **Inorder** gives us **left subtree first**, then root, then right subtree.

So, if we know the current root (from preorder), we can split the inorder array into:

* Elements before root → **Left subtree**
* Elements after root → **Right subtree**

We recursively build left and right subtrees.

---

# Approach

1. Use an index pointer (`preIndex`) that traverses `preorder`. Initially, it’s at the root (index `0`).
2. Create a **HashMap** from inorder values → index, for **O(1) lookup**.
3. Recursive function `buildTree(preorder, inorderMap, inStart, inEnd)`:

   * Base case: if `inStart > inEnd`, return `null`.
   * Take the current element from preorder\[preIndex] as root, then increment `preIndex`.
   * Find that element’s index in inorder (`inIndex = inorderMap.get(rootValue)`).
   * Recursively build left subtree (`inStart, inIndex - 1`).
   * Recursively build right subtree (`inIndex + 1, inEnd`).

---

# Complexity

* **Time:** `O(N)` (each node is processed once, lookup in hashmap is O(1))
* **Space:** `O(N)` (hashmap + recursion stack in worst case skewed tree)

---

# Code

```java
import java.util.*;

class TreeNode {
    int data;
    TreeNode left, right;
    TreeNode(int data) {
        this.data = data;
        this.left = null;
        this.right = null;
    }
}

public class Solution {
    private static int preIndex; // to keep track of preorder index

    public static TreeNode buildBinaryTree(int[] inorder, int[] preorder) {
        // build hashmap for inorder index lookup
        Map<Integer, Integer> inorderMap = new HashMap<>();
        for (int i = 0; i < inorder.length; i++) {
            inorderMap.put(inorder[i], i);
        }
        
        preIndex = 0;
        return build(preorder, inorderMap, 0, inorder.length - 1);
    }

    private static TreeNode build(int[] preorder, Map<Integer, Integer> inorderMap, int inStart, int inEnd) {
        if (inStart > inEnd) return null;

        // take current root from preorder
        int rootVal = preorder[preIndex++];
        TreeNode root = new TreeNode(rootVal);

        // find root in inorder
        int inIndex = inorderMap.get(rootVal);

        // recursively build left and right subtrees
        root.left = build(preorder, inorderMap, inStart, inIndex - 1);
        root.right = build(preorder, inorderMap, inIndex + 1, inEnd);

        return root;
    }
}
```

---

### Example Walkthrough

Input:

```
preorder = [1, 2, 4, 7, 3]  
inorder  = [4, 2, 7, 1, 3]  
```

Steps:

1. preorder\[0] = 1 → root. In inorder, `1` is at index 3.

   * Left inorder = \[4, 2, 7]
   * Right inorder = \[3]

2. preorder\[1] = 2 → left child of 1. In inorder, `2` at index 1.

   * Left inorder = \[4]
   * Right inorder = \[7]

3. preorder\[2] = 4 → left child of 2. In inorder, it has no children → leaf.

4. preorder\[3] = 7 → right child of 2. → leaf.

5. preorder\[4] = 3 → right child of 1. → leaf.

Final tree:

```
        1
       / \
      2   3
     / \
    4   7
```

---
