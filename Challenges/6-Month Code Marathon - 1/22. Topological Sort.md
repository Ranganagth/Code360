# Intuition

Topological sorting is possible only for **DAGs** (Directed Acyclic Graphs). The idea is to order nodes such that every directed edge `u â†’ v` places `u` before `v` in the order.
A good way to achieve this is by considering **in-degree** (number of incoming edges) of each node:

* A node with `in-degree = 0` has no dependencies and can appear first.
* Once placed in the ordering, we remove its outgoing edges, reducing in-degree of its neighbors.
* Repeat until all nodes are processed.

---

# Approach

1. **Build adjacency list** from given edges.
2. **Compute in-degree** of each vertex.
3. **Initialize a queue** with all vertices having `in-degree = 0` (no dependencies).
4. While the queue is not empty:

   * Remove a vertex from the queue, add it to result.
   * For each neighbor, reduce its in-degree by 1.
   * If in-degree becomes 0, push it into queue.
5. At the end, the result will contain a valid topological sort.

This ensures that each vertex appears **only after all its prerequisites** have been placed.

---

# Complexity

* **Time complexity:**
  Building adjacency + in-degree: `O(V + E)`
  Processing all vertices and edges: `O(V + E)`
  **Total:** `O(V + E)`

* **Space complexity:**

  * Adjacency list: `O(V + E)`
  * In-degree array: `O(V)`
  * Result storage: `O(V)`
    **Total:** `O(V + E)`

---

# Code

```java
import java.util.*;
import java.io.*;

public class Solution {
    public static ArrayList<Integer> topologicalSort(ArrayList<ArrayList<Integer>> edges, int v, int e) {
        // Step 1: Build adjacency list
        List<List<Integer>> adj = new ArrayList<>();
        for (int i = 0; i < v; i++) {
            adj.add(new ArrayList<>());
        }
        for (ArrayList<Integer> edge : edges) {
            int u = edge.get(0);
            int w = edge.get(1);
            adj.get(u).add(w);
        }

        // Step 2: Compute in-degree
        int[] indegree = new int[v];
        for (int u = 0; u < v; u++) {
            for (int nbr : adj.get(u)) {
                indegree[nbr]++;
            }
        }

        // Step 3: Initialize queue with in-degree 0 nodes
        Queue<Integer> q = new LinkedList<>();
        for (int i = 0; i < v; i++) {
            if (indegree[i] == 0) {
                q.offer(i);
            }
        }

        // Step 4: Process queue
        ArrayList<Integer> topo = new ArrayList<>();
        while (!q.isEmpty()) {
            int node = q.poll();
            topo.add(node);

            for (int nbr : adj.get(node)) {
                indegree[nbr]--;
                if (indegree[nbr] == 0) {
                    q.offer(nbr);
                }
            }
        }

        return topo;
    }
}
```

---
