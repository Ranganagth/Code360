# Intuition

We need to find, for each city, how many cities are reachable within a given distance threshold. Since we are dealing with **minimum path distances** between all pairs of cities, the problem naturally maps to the **All-Pairs Shortest Path (APSP)** problem.
The classic algorithm to solve APSP for `N <= 100` is **Floyd-Warshall**, which works in `O(N^3)` time and fits perfectly within constraints.

Once we have the shortest distance between every pair of cities, we simply count how many cities are reachable within the threshold for each city. Then pick the city with:

1. The minimum reachable count.
2. If a tie occurs, choose the city with the **greatest index**.

---

# Approach

1. **Initialize Distance Matrix:**
   Create an `N x N` matrix `dist`, where `dist[i][j]` = weight of edge between `i` and `j` if exists, otherwise set to infinity. Set `dist[i][i] = 0`.

2. **Run Floyd-Warshall:**
   Update shortest paths using the triple nested loop:

   ```
   for k in 0..N-1:
       for i in 0..N-1:
           for j in 0..N-1:
               dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
   ```

3. **Count Reachable Cities:**
   For each city `i`, count how many cities `j` have `dist[i][j] <= distanceThreshold`.

4. **Find the Answer:**
   Track the city with the minimum reachable count, resolving ties by selecting the city with the greater index.

---

# Complexity

* **Time Complexity:**
  Floyd-Warshall takes `O(N^3)`. With `N <= 100`, this is `10^6` operations, which is efficient.
* **Space Complexity:**
  `O(N^2)` for storing the distance matrix.

---

# Code

```java
import java.util.*;

public class Solution {
    public static int findTheCity(int n, ArrayList<ArrayList<Integer>> edges, int distanceThreshold) {
        final int INF = (int)1e9;
        int[][] dist = new int[n][n];

        // Initialize distance matrix
        for (int i = 0; i < n; i++) {
            Arrays.fill(dist[i], INF);
            dist[i][i] = 0;
        }

        // Add edges
        for (ArrayList<Integer> edge : edges) {
            int u = edge.get(0);
            int v = edge.get(1);
            int w = edge.get(2);
            dist[u][v] = w;
            dist[v][u] = w;
        }

        // Floyd-Warshall Algorithm
        for (int k = 0; k < n; k++) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    if (dist[i][k] + dist[k][j] < dist[i][j]) {
                        dist[i][j] = dist[i][k] + dist[k][j];
                    }
                }
            }
        }

        // Count reachable cities
        int answerCity = -1;
        int minReachable = Integer.MAX_VALUE;

        for (int i = 0; i < n; i++) {
            int count = 0;
            for (int j = 0; j < n; j++) {
                if (i != j && dist[i][j] <= distanceThreshold) {
                    count++;
                }
            }
            // Pick city with fewer neighbors, break ties with larger index
            if (count < minReachable || (count == minReachable && i > answerCity)) {
                minReachable = count;
                answerCity = i;
            }
        }

        return answerCity;
    }

    // Example test runner
    public static void main(String[] args) {
        ArrayList<ArrayList<Integer>> edges1 = new ArrayList<>();
        edges1.add(new ArrayList<>(Arrays.asList(0, 1, 1)));
        edges1.add(new ArrayList<>(Arrays.asList(1, 2, 1)));
        edges1.add(new ArrayList<>(Arrays.asList(2, 3, 3)));
        edges1.add(new ArrayList<>(Arrays.asList(3, 4, 1)));
        edges1.add(new ArrayList<>(Arrays.asList(0, 3, 3)));

        System.out.println(findTheCity(5, edges1, 3)); // Expected 4

        ArrayList<ArrayList<Integer>> edges2 = new ArrayList<>();
        edges2.add(new ArrayList<>(Arrays.asList(0, 1, 2)));
        edges2.add(new ArrayList<>(Arrays.asList(1, 2, 2)));
        edges2.add(new ArrayList<>(Arrays.asList(2, 0, 1)));

        System.out.println(findTheCity(3, edges2, 4)); // Expected 2
    }
}
```

---

# Example Walkthrough

### Input

```
5 5 3
0 1 1
1 2 1
2 3 3
3 4 1
0 3 3
```

* After running Floyd-Warshall, shortest distances are:

  * City 0 → {1, 2, 3}
  * City 1 → {0, 2}
  * City 2 → {0, 1, 3}
  * City 3 → {0, 2, 4}
  * City 4 → {3}
* Reachable counts: `[3, 2, 3, 3, 1]`
* Minimum is `1` for city `4`.
  **Output:** `4`.

---
