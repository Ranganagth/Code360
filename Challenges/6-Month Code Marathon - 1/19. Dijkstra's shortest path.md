# Intuition

When all edge weights are **non-negative**, Dijkstra's algorithm is the most efficient way to find the **shortest distance** from a source node to all other nodes. It uses a **min-heap (priority queue)** to always expand the next nearest node, ensuring optimal distances are calculated efficiently.

---

# Approach

1. **Graph Representation**: Use an adjacency list to store the graph as `Map<Integer, List<Pair<neighbour, weight>>>`.

2. **Distance Array**: Initialize all distances to `Integer.MAX_VALUE`, except for the source node which is set to 0.

3. **Priority Queue**: Store pairs of `(distance, node)` to ensure we always expand the node with the current shortest known distance.

4. **Relaxation**: For each node popped from the queue, iterate through its neighbors and update their distances if a shorter path is found.

5. **Result**: Return the final `distance` list.

---

# Complexity

* **Time complexity**:
  $O((V + E) \cdot \log V)$
  where `V` is the number of vertices and `E` is the number of edges.

* **Space complexity**:
  $O(V + E)$
  for storing the graph and distance array.

---

# Code

```java
import java.util.*;

public class Solution {
    static class Pair {
        int node, weight;
        Pair(int n, int w) {
            this.node = n;
            this.weight = w;
        }
    }

    public static List<Integer> dijkstra(int[][] edge, int vertices, int edges, int source) {
        // Step 1: Build the graph (undirected)
        List<List<Pair>> graph = new ArrayList<>();
        for (int i = 0; i < vertices; i++) {
            graph.add(new ArrayList<>());
        }
        for (int[] e : edge) {
            int u = e[0], v = e[1], w = e[2];
            graph.get(u).add(new Pair(v, w));
            graph.get(v).add(new Pair(u, w));
        }

        // Step 2: Distance array
        int[] dist = new int[vertices];
        Arrays.fill(dist, Integer.MAX_VALUE);
        dist[source] = 0;

        // Step 3: Min-heap for Dijkstra
        PriorityQueue<Pair> pq = new PriorityQueue<>((a, b) -> a.weight - b.weight);
        pq.offer(new Pair(source, 0));

        while (!pq.isEmpty()) {
            Pair curr = pq.poll();
            int u = curr.node;
            int d = curr.weight;

            // Process neighbors
            for (Pair neighbor : graph.get(u)) {
                int v = neighbor.node;
                int weight = neighbor.weight;
                if (d + weight < dist[v]) {
                    dist[v] = d + weight;
                    pq.offer(new Pair(v, dist[v]));
                }
            }
        }

        // Convert result to List<Integer>
        List<Integer> result = new ArrayList<>();
        for (int d : dist) result.add(d);
        return result;
    }
}
```

