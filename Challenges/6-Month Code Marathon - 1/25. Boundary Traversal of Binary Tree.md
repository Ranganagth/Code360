# Intuition

To print boundary nodes in anti-clockwise order:

1. Start with the **root**.
2. Print the **left boundary** (excluding leaf nodes).
3. Print all the **leaf nodes** from left to right.
4. Print the **right boundary** (excluding leaf nodes) **in reverse order**.

Key point: Ensure each node is added **once**, even if it belongs to multiple categories (like root or leaf in boundary).

---

# Approach

1. **Root**: Always add the root first.
2. **Left Boundary**:

   * Start from `root.left`.
   * Traverse down preferring `.left` child, if not available then `.right`.
   * Stop before leaf nodes (because they’ll be covered in step 3).
3. **Leaf Nodes**:

   * Traverse the tree using DFS.
   * Add nodes which are leaves (no left, no right).
4. **Right Boundary**:

   * Start from `root.right`.
   * Traverse down preferring `.right` child, if not available then `.left`.
   * Stop before leaf nodes.
   * Add them to a temporary list and then reverse it before appending.

---

# Complexity

* **Time Complexity**:
  O(N), since each node is visited at most once.
* **Space Complexity**:
  O(H) recursion stack for DFS (worst-case O(N) for skewed tree).

---

# Code

```java
/************************************************************

 Following is the Binary Tree node structure:

 class TreeNode {
     int data;
     TreeNode left;
     TreeNode right;

     TreeNode(int data) {
         this.data = data;
         this.left = null;
         this.right = null;
     }
 }

 ************************************************************/

import java.util.*;

public class Solution {
    public static List<Integer> traverseBoundary(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null) return result;

        // Root is always part of boundary (unless it's the only node)
        if (!isLeaf(root)) {
            result.add(root.data);
        }

        // Add left boundary
        addLeftBoundary(root.left, result);

        // Add leaf nodes
        addLeaves(root, result);

        // Add right boundary
        addRightBoundary(root.right, result);

        return result;
    }

    // Utility to check leaf node
    private static boolean isLeaf(TreeNode node) {
        return node != null && node.left == null && node.right == null;
    }

    // Left boundary (excluding leaves)
    private static void addLeftBoundary(TreeNode node, List<Integer> result) {
        TreeNode curr = node;
        while (curr != null) {
            if (!isLeaf(curr)) {
                result.add(curr.data);
            }
            if (curr.left != null) {
                curr = curr.left;
            } else {
                curr = curr.right;
            }
        }
    }

    // Add all leaf nodes
    private static void addLeaves(TreeNode node, List<Integer> result) {
        if (node == null) return;
        if (isLeaf(node)) {
            result.add(node.data);
            return;
        }
        addLeaves(node.left, result);
        addLeaves(node.right, result);
    }

    // Right boundary (excluding leaves, added in reverse)
    private static void addRightBoundary(TreeNode node, List<Integer> result) {
        List<Integer> temp = new ArrayList<>();
        TreeNode curr = node;
        while (curr != null) {
            if (!isLeaf(curr)) {
                temp.add(curr.data);
            }
            if (curr.right != null) {
                curr = curr.right;
            } else {
                curr = curr.left;
            }
        }
        // Add in reverse order
        for (int i = temp.size() - 1; i >= 0; i--) {
            result.add(temp.get(i));
        }
    }
}
```

---

## Example Walkthrough

Input:

```
10 5 20 3 8 18 25 -1 -1 7 -1 -1 -1 -1 -1 -1 -1
```

Tree:

```
        10
      /    \
     5      20
    / \    /  \
   3   8  18  25
        /
       7
```

* Root: `[10]`
* Left boundary: `[5, 3]`
* Leaf nodes: `[3, 7, 18, 25]` (skip duplicates)
* Right boundary: `[20, 25]` → reversed `[25, 20]` but 25 is leaf, so only `[20]`.

Final Answer:
`[10, 5, 3, 7, 18, 25, 20]`

---
``