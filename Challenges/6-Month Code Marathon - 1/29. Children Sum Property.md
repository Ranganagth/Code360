# Intuition

We need to check if **every non-leaf node’s value equals the sum of its children**:

* If a node is a leaf, it automatically satisfies the property.
* If a node is non-leaf, check:

  * `node.data == left.data + right.data` (treat null child as 0)
  * Recursively check the left and right subtrees.

---

# Approach (Recursive)

1. **Base case:**

   * If `root == null` → return `true`.
   * If `root` is a leaf → return `true`.
2. **Calculate sum of children:**

   * `leftValue = root.left != null ? root.left.data : 0`
   * `rightValue = root.right != null ? root.right.data : 0`
3. **Check current node:**

   * If `root.data != leftValue + rightValue` → return `false`.
4. **Recur on left and right subtrees:**

   * Return `isParentSum(root.left) && isParentSum(root.right)`.

---

# Complexity

* **Time Complexity:** `O(N)` → Each node is visited once.
* **Space Complexity:** `O(H)` → Recursion stack, where `H` is the height of the tree (`O(log N)` for balanced, `O(N)` for skewed).

---

# Code

```java
public class Solution {
    public static boolean isParentSum(Node root) {
        if (root == null) return true;

        // If leaf node, property satisfied
        if (root.left == null && root.right == null) return true;

        int leftValue = (root.left != null) ? root.left.data : 0;
        int rightValue = (root.right != null) ? root.right.data : 0;

        if (root.data != leftValue + rightValue) return false;

        return isParentSum(root.left) && isParentSum(root.right);
    }
}
```

---

## Example Walkthrough

### Sample Input:

```
      5
     / \
    3   2
   / \
  3   -1
```

Tree (after ignoring -1 as nulls):

```
      5
     / \
    3   2
   /
  3
```

**Steps:**

1. Root `5`: left=3, right=2 → sum=5 → matches.
2. Node `3`: left=3, right=null → sum=3 → matches.
3. Node `2`: leaf → matches.
4. Node `3`: leaf → matches.

**Output:** `true`

---
