# Intuition

We need to find the shortest path from a single source to all other vertices. Since edge weights can be negative, **Dijkstra’s algorithm won’t work**. Instead, **Bellman-Ford algorithm** is suitable because it works correctly even with negative weights, as long as there are no negative cycles.

---

# Approach

1. **Initialization**:

   * Create a distance array `dist` of size `n+1` (1-indexed).
   * Set all distances to `1e8` (as per problem statement).
   * Set `dist[src] = 0` since distance from source to itself is 0.

2. **Relax all edges (n-1) times**:

   * For each edge `(u, v, w)`, if `dist[u] + w < dist[v]`, then update `dist[v] = dist[u] + w`.
   * Repeat this process `n-1` times because in the worst case, the shortest path can have `n-1` edges.

3. **Handle unreachable nodes**:

   * If a node remains `1e8`, it means it’s not reachable from the source.

4. **Return the result**:

   * Return the distance array excluding index `0`.

---

# Complexity

* **Time complexity**:
  For each of the `n-1` iterations, we process all `m` edges.
  **O(n \* m)** → With constraints (`n <= 50`, `m <= 300`), this is efficient.

* **Space complexity**:
  `O(n)` for the distance array.

---

# Code (C++)

```cpp

vector<int> bellmonFord(int n, int m, int src, vector<vector<int>> &edges) {

    // Create a vector to store the distances from source.
    vector<int> d(n + 1, 1e8);
    // Distance of source to source is 0.
    d[src] = 0;

    // Apply bellmonford algorithm.
    for (int i = 1; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            int u = edges[j][0];
            int v = edges[j][1];
            int w = edges[j][2];

            if (d[u] != 1e9 && d[v] > (d[u] + w)) {
                d[v] = d[u] + w;
            }
        }
    }

    // Return the distance of destination.
    return d;

}

```

---

# Example Walkthrough

### Input:

```
4 4 1
1 2 4
1 3 3
2 4 7
3 4 -2
```

### Steps:

* Initialize `dist = [INF, 0, INF, INF, INF]`
* Relax edges 3 times:

  * Iteration 1:

    * (1→2,4): dist\[2] = 4
    * (1→3,3): dist\[3] = 3
    * (2→4,7): dist\[4] = 11
    * (3→4,-2): dist\[4] = 1
  * Iteration 2 & 3: no further updates.

### Final distances:

`[0, 4, 3, 1]`

---
# Code (Java 17)

```java
import java.util.*;

public class Solution {
    public static int[] bellmonFord(int n, int m, int src, List<List<Integer>> edges) {
        int INF = (int) 1e8;
        int[] dist = new int[n + 1]; // 1-based indexing

        Arrays.fill(dist, INF);
        dist[src] = 0;

        // Relax edges (n-1) times
        for (int i = 1; i <= n - 1; i++) {
            for (List<Integer> edge : edges) {
                int u = edge.get(0);
                int v = edge.get(1);
                int w = edge.get(2);

                if (dist[u] != INF && dist[u] + w < dist[v]) {
                    dist[v] = dist[u] + w;
                }
            }
        }

        // Prepare result (0-based indexing)
        int[] result = new int[n];
        for (int i = 1; i <= n; i++) {
            result[i - 1] = dist[i];
        }
        return result;
    }
}

```